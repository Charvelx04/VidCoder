<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Save" xml:space="preserve">
    <value>Save</value>
  </data>
  <data name="SaveAs" xml:space="preserve">
    <value>Save As...</value>
  </data>
  <data name="Revert" xml:space="preserve">
    <value>Revert</value>
  </data>
  <data name="Advanced_AdaptiveBFramesToolTip" xml:space="preserve">
    <value>x264 has a variety of algorithms to decide when to use B-frames and how many to use.

Fast mode takes roughly the same amount of time no matter how many B-frames you specify.  However, while fast, its decisions are often suboptimal.

Optimal mode gets slower as the maximum number of B-Frames increases, but makes much more accurate decisions, especially when used with B-pyramid.</value>
  </data>
  <data name="Advanced_AdaptiveDirectModeToolTip" xml:space="preserve">
    <value>H.264 allows for two different prediction modes, spatial and temporal, in B-frames.

Spatial, the default, is almost always better, but temporal is sometimes useful too.

x264 can, at the cost of a small amount of speed (and accordingly for a small compression gain), adaptively select which is better for each particular frame.</value>
  </data>
  <data name="Advanced_AdaptiveQuantizationStrengthToolTip" xml:space="preserve">
    <value>Adaptive quantization controls how the encoder distributes bits across the frame.
Higher values take more bits away from edges and complex areas to improve areas with finer detail.</value>
  </data>
  <data name="Advanced_AnalysisToolTip" xml:space="preserve">
    <value>Mode decision picks from a variety of options to make its decision: this option chooses what options those are.  
Fewer partitions to check means faster encoding, at the cost of worse decisions, since the best option might have been one that was turned off.</value>
  </data>
  <data name="Advanced_BFramesToolTip" xml:space="preserve">
    <value>Sane values are ~2-5.  
This specifies the maximum number of sequential B-frames that the encoder can use. 
 Large numbers generally won't help significantly unless Adaptive B-frames is set to Optimal.  
Cel-animated source material and B-pyramid also significantly increase the usefulness of larger values. 
Baseline profile, as required for iPods and similar devices, requires B-frames to be set to 0 (off).</value>
  </data>
  <data name="Advanced_CabacToolTip" xml:space="preserve">
    <value>After the encoder has done its work, it has a bunch of data that needs to be compressed losslessly, similar to ZIP or RAR. H.264 provides two options for this: CAVLC and CABAC.  CABAC decodes a lot slower but compresses significantly better (10-30%), especially at lower bitrates. If you're looking to minimize CPU requirements for video playback, disable this option. Baseline profile, as required for iPods and similar devices, requires CABAC to be disabled.</value>
  </data>
  <data name="Advanced_DeblockingToolTip" xml:space="preserve">
    <value>H.264 has a built-in deblocking filter that smooths out blocking artifacts after decoding each frame.  This not only improves visual quality, but also helps compression significantly. 
The deblocking filter takes a lot of CPU power, so if you're looking to minimize CPU requirements for video playback, disable it.

The deblocking filter has two adjustable parameters, "strength" and "threshold". 
The former controls how strong (or weak) the deblocker is, while the latter controls how many (or few)  edges it applies to. 
Lower values mean less deblocking, higher values mean more deblocking. The default is 0 (normal strength) for both parameters.</value>
  </data>
  <data name="Advanced_EightByEightDctToolTip" xml:space="preserve">
    <value>The 8x8 transform is the single most useful feature of x264 in terms of compression-per-speed.  
It improves compression by at least 5% at a very small speed cost and may provide an unusually high visual quality benefit compared to its compression gain.  
However, it requires High Profile, which many devices may not support.</value>
  </data>
  <data name="Advanced_MotionEstimationMethodToolTip" xml:space="preserve">
    <value>Controls the motion estimation method. Motion estimation is how the encoder estimates how each block of pixels in a frame has moved.  
A better motion search method improves compression at the cost of speed.

Diamond: performs an extremely fast and simple search using a diamond pattern.

Hexagon: performs a somewhat more effective but slightly slower search using a hexagon pattern.

Uneven Multi-Hex: performs a very wide search using a variety of patterns, more accurately capturing complex motion.

Exhaustive: performs a "dumb" search of every pixel in a wide area.  Significantly slower for only a small compression gain.

Transformed Exhaustive: Like exhaustive, but makes even more accurate decisions. Accordingly, somewhat slower, also for only a small improvement.</value>
  </data>
  <data name="Advanced_MotionEstimationRangeToolTip" xml:space="preserve">
    <value>This is the distance x264 searches from its best guess at the motion of a block in order to try to find its actual motion.  
Doesn't apply to Diamond or Hexagon search options.  
The default is fine for most content, but extremely high motion video, especially at HD resolutions, may benefit from higher ranges, albeit at a high speed cost.</value>
  </data>
  <data name="Advanced_NoDctDecimateToolTip" xml:space="preserve">
    <value>x264 normally zeroes out nearly-empty data blocks to save bits to be better used for some other purpose in the video.  
However, this can sometimes have slight negative effects on retention of subtle grain and dither.  
Don't touch this unless you're having banding issues or other such cases where you are having trouble keeping fine noise.</value>
  </data>
  <data name="Advanced_PsychovisualRateDistortionToolTip" xml:space="preserve">
    <value>Psychovisual Rate Distortion means x264 tries to retain detail, for better quality to the human eye, 
as opposed to trying to maximize quality the way a computer understands it, through signal-to-noise ratios that have trouble telling apart fine detail and noise.</value>
  </data>
  <data name="Advanced_PsychovisualTrellisToolTip" xml:space="preserve">
    <value>Psychovisual Trellis tries to retain more sharpness and detail, but can cause artifacting.
It is considered experimental, which is why it's off by default. Good values are 0.1 to 0.2.</value>
  </data>
  <data name="Advanced_PyramidalBFramesToolTip" xml:space="preserve">
    <value>B-pyramid improves compression by creating a pyramidal structure (hence the name) of B-frames, allowing B-frames to 
reference each other to improve compression.  

Requires Max B-frames greater than 1; optimal adaptive B-frames is strongly recommended for full compression benefit.</value>
  </data>
  <data name="Advanced_ReferenceFramesToolTip" xml:space="preserve">
    <value>Sane values are ~1-6.

The more you add, the better the compression, but the slower the encode.

Cel animation tends to benefit from more reference frames a lot more than film content.

Note that many hardware devices have limitations on the number of supported reference frames, so if you're encoding for a handheld or standalone player, don't touch this unless you're absolutely sure you know what you're doing!</value>
  </data>
  <data name="Advanced_SubpixelMotionEstimationToolTip" xml:space="preserve">
    <value>This setting controls both subpixel-precision motion estimation and mode decision methods.

Subpixel motion estimation is used for refining motion estimates beyond mere pixel accuracy, improving compression.

Mode decision is the method used to choose how to encode each block of the frame: a very important decision.

SAD is the fastest method, followed by SATD, RD, RD refinement, and the slowest, QPRD.
6 or higher is strongly recommended: Psy-RD, a very powerful psy optimization that helps retain detail, requires RD.
10, the most powerful and slowest option, requires trellis=2.</value>
  </data>
  <data name="Advanced_TrellisToolTip" xml:space="preserve">
    <value>Trellis fine-tunes the rounding of transform coefficients to squeeze out 3-5% more compression at the cost of some speed. 
"Always" uses trellis not only during the main encoding process, but also during analysis, which improves compression even more, albeit at great speed cost. 

Trellis costs more speed at higher bitrates.</value>
  </data>
  <data name="Advanced_WeightPToolTip" xml:space="preserve">
    <value>Performs extra analysis to decide upon weighting parameters for each frame.  
This improves overall compression slightly and improves the quality of fades greatly. 
Baseline profile, as required for iPods and similar devices, requires weighted P-frame prediction to be disabled.  
Note that some devices and players, even those that support Main Profile, 
may have problems with Weighted P-frame prediction: the Apple TV is completely incompatible with it, for example.</value>
  </data>
  <data name="Audio_DrcToolTip" xml:space="preserve">
    <value>Dynamic Range Compression. Valid values are 0-4.

For source audio that has a wide dynamic range (very loud and very soft sequences), DRC allows you to "compress" the range by making loud sections softer and soft sections louder.</value>
  </data>
  <data name="Audio_GainToolTip" xml:space="preserve">
    <value>Amplify or attenuate audio before encoding. Valid values are -20 to +20 dB.</value>
  </data>
  <data name="IncludeChapterMarkersToolTip" xml:space="preserve">
    <value>Include chapter markers from the input video in the encoded video.</value>
  </data>
  <data name="IPod5GSupportToolTip" xml:space="preserve">
    <value>Applies a marker to the file that older iPods require before they'll allow H.264 video to sync.</value>
  </data>
  <data name="LargeFileSizeToolTip" xml:space="preserve">
    <value>Allows files over 4GB. When enabled, uses 64-bit numbers in encoding. Some devices such as the iPod and PS3 are incompatible with this option.</value>
  </data>
  <data name="PixelAspectRatioToolTip" xml:space="preserve">
    <value>Manually specify a Pixel Aspect Ratio.</value>
  </data>
  <data name="Video_QualityTargetToolTip" xml:space="preserve">
    <value>Set the desired quality factor. The scale used by each video encoder is different.</value>
  </data>
  <data name="WebOptimizedToolTip" xml:space="preserve">
    <value>Arrange file to play better as a progressive download.</value>
  </data>
  <data name="X264PresetToolTip" xml:space="preserve">
    <value>Change options to trade off compression efficiency against encoding speed. If you specify a preset, the changes it makes will be applied before all other parameters are applied.</value>
  </data>
  <data name="X264ProfileToolTip" xml:space="preserve">
    <value>Limit the profile of the output stream. If you specify a profile, it overrides all other settings, so if you use it, you will be guaranteed a compatible stream.

You should set this if you know your playback device only supports a certain profile.</value>
  </data>
  <data name="X264TuneToolTip" xml:space="preserve">
    <value>Tune options to further optimize them for your input content. If you specify a tuning, the changes will be applied after the Preset but before all other parameters.</value>
  </data>
  <data name="DisplayWidthToolTip" xml:space="preserve">
    <value>The desired display width of the video. Other parameters such as the Pixel Aspect Ratio will be changed to acheive this.</value>
  </data>
  <data name="ContainerLabel" xml:space="preserve">
    <value>Container:</value>
  </data>
  <data name="ExtensionLabel" xml:space="preserve">
    <value>Extension:</value>
  </data>
  <data name="LargeFileSizeCheckBox" xml:space="preserve">
    <value>Large file size</value>
  </data>
  <data name="WebOptimizedCheckBox" xml:space="preserve">
    <value>Web optimized</value>
  </data>
  <data name="Ipod5GSupportCheckBox" xml:space="preserve">
    <value>iPod 5G support</value>
  </data>
  <data name="IncludeChapterMarkersCheckBox" xml:space="preserve">
    <value>Include chapter markers</value>
  </data>
  <data name="TabHeader_Picture" xml:space="preserve">
    <value>Picture</value>
  </data>
  <data name="TabHeader_VideoFilters" xml:space="preserve">
    <value>Video Filters</value>
  </data>
  <data name="TabHeader_Video" xml:space="preserve">
    <value>Video</value>
  </data>
  <data name="TabHeader_Audio" xml:space="preserve">
    <value>Audio</value>
  </data>
  <data name="TabHeader_Advanced" xml:space="preserve">
    <value>Advanced</value>
  </data>
  <data name="Rename" xml:space="preserve">
    <value>Rename</value>
  </data>
  <data name="Input" xml:space="preserve">
    <value>Input</value>
  </data>
  <data name="AutoCaption" xml:space="preserve">
    <value>(auto)</value>
  </data>
  <data name="NoneCaption" xml:space="preserve">
    <value>(none)</value>
  </data>
  <data name="StorageResolutionLabel" xml:space="preserve">
    <value>Storage Resolution:</value>
  </data>
  <data name="PixelAspectRatioLabel" xml:space="preserve">
    <value>Pixel Aspect Ratio:</value>
  </data>
  <data name="DisplayResolutionLabel" xml:space="preserve">
    <value>Display Resolution:</value>
  </data>
  <data name="SizingLabel" xml:space="preserve">
    <value>Sizing</value>
  </data>
  <data name="WidthLabel" xml:space="preserve">
    <value>Width:</value>
  </data>
  <data name="HeightLabel" xml:space="preserve">
    <value>Height:</value>
  </data>
  <data name="MaxWidthLabel" xml:space="preserve">
    <value>Max Width:</value>
  </data>
  <data name="MaxHeightLabel" xml:space="preserve">
    <value>Max Height:</value>
  </data>
  <data name="KeepAspectRatioCheckBox" xml:space="preserve">
    <value>Keep Aspect Ratio</value>
  </data>
  <data name="AnamorphicLabel" xml:space="preserve">
    <value>Anamorphic:</value>
  </data>
  <data name="ModulusLabel" xml:space="preserve">
    <value>Modulus:</value>
  </data>
  <data name="DisplayWidthRadioButton" xml:space="preserve">
    <value>Display Width:</value>
  </data>
  <data name="PixelAspectRatioRadioButton" xml:space="preserve">
    <value>Pixel Aspect Ratio:</value>
  </data>
  <data name="OutputLabel" xml:space="preserve">
    <value>Output</value>
  </data>
  <data name="CroppingLabel" xml:space="preserve">
    <value>Cropping</value>
  </data>
  <data name="Top" xml:space="preserve">
    <value>Top</value>
  </data>
  <data name="Left" xml:space="preserve">
    <value>Left</value>
  </data>
  <data name="Bottom" xml:space="preserve">
    <value>Bottom</value>
  </data>
  <data name="Right" xml:space="preserve">
    <value>Right</value>
  </data>
  <data name="DetelecineLabel" xml:space="preserve">
    <value>Detelecine:</value>
  </data>
  <data name="DecombLabel" xml:space="preserve">
    <value>Decomb:</value>
  </data>
  <data name="DeinterlaceLabel" xml:space="preserve">
    <value>Deinterlace:</value>
  </data>
  <data name="DenoiseLabel" xml:space="preserve">
    <value>Denoise:</value>
  </data>
  <data name="DeblockLabel" xml:space="preserve">
    <value>Deblock:</value>
  </data>
  <data name="GrayscaleCheckBox" xml:space="preserve">
    <value>Grayscale encoding</value>
  </data>
  <data name="TypeLabel" xml:space="preserve">
    <value>Type:</value>
  </data>
  <data name="ShortCodecLabel" xml:space="preserve">
    <value>Codec:</value>
  </data>
  <data name="ShortFramerateLabel" xml:space="preserve">
    <value>Framerate:</value>
  </data>
  <data name="CodecLabel">
    <value xml:space="preserve">Video Codec:</value>
  </data>
  <data name="FramerateLabel">
    <value xml:space="preserve">Framerate (FPS):</value>
  </data>
  <data name="ConstantFramerateRadioButton">
    <value xml:space="preserve">Constant Framerate</value>
  </data>
  <data name="Quality">
    <value xml:space="preserve">Quality</value>
  </data>
  <data name="TwoPassEncodingCheckBox">
    <value xml:space="preserve">2-pass Encoding</value>
  </data>
  <data name="TurboFirstPassCheckBox">
    <value xml:space="preserve">Turbo first Pass</value>
  </data>
  <data name="TargetSizeRadioButton">
    <value xml:space="preserve">Target Size (MB)</value>
  </data>
  <data name="AverageBitrateRadioButton">
    <value xml:space="preserve">Avg Bitrate (kbps)</value>
  </data>
  <data name="ConstantQualityRadioButton">
    <value xml:space="preserve">Constant Quality</value>
  </data>
  <data name="X264BasicSettings">
    <value xml:space="preserve">x264 Basic Settings</value>
  </data>
  <data name="ProfileLabel">
    <value xml:space="preserve">Profile:</value>
  </data>
  <data name="PresetLabel">
    <value xml:space="preserve">Preset:</value>
  </data>
  <data name="TuneLabel">
    <value xml:space="preserve">Tune:</value>
  </data>
  <data name="NoneX264Choice">
    <value xml:space="preserve">-None-</value>
  </data>
  <data name="Profile_Baseline">
    <value xml:space="preserve">Baseline</value>
  </data>
  <data name="Profile_Main">
    <value xml:space="preserve">Main</value>
  </data>
  <data name="Profile_High">
    <value xml:space="preserve">High</value>
  </data>
  <data name="Preset_UltraFast">
    <value xml:space="preserve">Ultra Fast</value>
  </data>
  <data name="Preset_SuperFast">
    <value xml:space="preserve">Super Fast</value>
  </data>
  <data name="Preset_VeryFast">
    <value xml:space="preserve">Very Fast</value>
  </data>
  <data name="Preset_Faster">
    <value xml:space="preserve">Faster</value>
  </data>
  <data name="Preset_Fast">
    <value xml:space="preserve">Fast</value>
  </data>
  <data name="Preset_Medium">
    <value xml:space="preserve">Medium</value>
  </data>
  <data name="Preset_Slow">
    <value xml:space="preserve">Slow</value>
  </data>
  <data name="Preset_Slower">
    <value xml:space="preserve">Slower</value>
  </data>
  <data name="Preset_VerySlow">
    <value xml:space="preserve">Very Slow</value>
  </data>
  <data name="Preset_Placebo">
    <value xml:space="preserve">Placebo</value>
  </data>
  <data name="Tune_Film">
    <value xml:space="preserve">Film</value>
  </data>
  <data name="Tune_Animation">
    <value xml:space="preserve">Animation</value>
  </data>
  <data name="Tune_Grain">
    <value xml:space="preserve">Grain</value>
  </data>
  <data name="Tune_StillImage">
    <value xml:space="preserve">Still Image</value>
  </data>
  <data name="Tune_Psnr">
    <value xml:space="preserve">PSNR</value>
  </data>
  <data name="Tune_Ssim">
    <value xml:space="preserve">SSIM</value>
  </data>
  <data name="Tune_FastDecode">
    <value xml:space="preserve">Fast Decode</value>
  </data>
  <data name="Tune_ZeroLatency">
    <value xml:space="preserve">Zero Latency</value>
  </data>
  <data name="FpsFormat">
    <value xml:space="preserve">{0:0.###} FPS</value>
  </data>
  <data name="CfrSameAsSourceToolTip">
    <value xml:space="preserve">Uses the listed framerate from the source title for a constant framerate.</value>
  </data>
  <data name="CfrToolTip">
    <value xml:space="preserve">Use a constant frame rate.</value>
  </data>
  <data name="VfrSameAsSourceToolTip">
    <value xml:space="preserve">Allow a variable framerate. If the source has a variable frame rate, this setting will preserve it. Note that some players do not support variable frame rates.</value>
  </data>
  <data name="VfrPeakFramerateToolTip">
    <value xml:space="preserve">Allow a variable framerate and use the specified rate as a peak. If the source has a variable frame rate, this setting will preserve it. Note that some players do not support variable frame rates.</value>
  </data>
  <data name="VfrChoice">
    <value xml:space="preserve">Variable Framerate</value>
  </data>
  <data name="VfrPeakChoice">
    <value xml:space="preserve">Peak Framerate (VFR)</value>
  </data>
  <data name="HighQuality">
    <value xml:space="preserve">High quality</value>
  </data>
  <data name="LowQuality">
    <value xml:space="preserve">Low quality</value>
  </data>
  <data name="SameAsSource">
    <value xml:space="preserve">Same as source</value>
  </data>
</root>